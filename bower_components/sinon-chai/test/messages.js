"use strict";var sinon=require("sinon"),expect=require("chai").expect,swallow=require("./common").swallow;describe("Messages",function(){describe("about call count",function(){it("should be correct for the base cases",function(){var e=sinon.spy();expect(function(){e.should.have.been.called}).to.throw("expected spy to have been called at least once, but it was never called"),expect(function(){e.should.have.been.calledOnce}).to.throw("expected spy to have been called exactly once, but it was called 0 times"),expect(function(){e.should.have.been.calledTwice}).to.throw("expected spy to have been called exactly twice, but it was called 0 times"),expect(function(){e.should.have.been.calledThrice}).to.throw("expected spy to have been called exactly thrice, but it was called 0 times"),expect(function(){e.should.have.callCount(1)}).to.throw("expected spy to have been called exactly once, but it was called 0 times"),expect(function(){e.should.have.callCount(4)}).to.throw("expected spy to have been called exactly 4 times, but it was called 0 times")}),it("should be correct for the negated cases",function(){var e=sinon.spy(),t=sinon.spy(),o=sinon.spy(),n=sinon.spy();e(),t(),t(),o(),o(),o(),n(),n(),n(),n(),expect(function(){e.should.not.have.been.called}).to.throw("expected spy to not have been called"),expect(function(){e.should.not.have.been.calledOnce}).to.throw("expected spy to not have been called exactly once"),expect(function(){t.should.not.have.been.calledTwice}).to.throw("expected spy to not have been called exactly twice"),expect(function(){o.should.not.have.been.calledThrice}).to.throw("expected spy to not have been called exactly thrice"),expect(function(){e.should.not.have.callCount(1)}).to.throw("expected spy to not have been called exactly once"),expect(function(){n.should.not.have.callCount(4)}).to.throw("expected spy to not have been called exactly 4 times")})}),describe("about call order",function(){it("should be correct for the base cases",function(){var e=sinon.spy(),t=sinon.spy();e.displayName="spyA",t.displayName="spyB",expect(function(){e.should.have.been.calledBefore(t)}).to.throw("expected spyA to have been called before function spyB() {}"),e.calledImmediatelyBefore&&expect(function(){e.should.have.been.calledImmediatelyBefore(t)}).to.throw("expected spyA to have been called immediately before function spyB() {}"),expect(function(){t.should.have.been.calledAfter(e)}).to.throw("expected spyB to have been called after function spyA() {}"),t.calledImmediatelyAfter&&expect(function(){t.should.have.been.calledImmediatelyAfter(e)}).to.throw("expected spyB to have been called immediately after function spyA() {}")}),it("should be correct for the negated cases",function(){var e=sinon.spy(),t=sinon.spy();e.displayName="spyA",t.displayName="spyB",e(),t(),expect(function(){e.should.not.have.been.calledBefore(t)}).to.throw("expected spyA to not have been called before function spyB() {}"),e.calledImmediatelyBefore&&expect(function(){e.should.not.have.been.calledImmediatelyBefore(t)}).to.throw("expected spyA to not have been called immediately before function spyB() {}"),expect(function(){t.should.not.have.been.calledAfter(e)}).to.throw("expected spyB to not have been called after function spyA() {}"),t.calledImmediatelyAfter&&expect(function(){t.should.not.have.been.calledImmediatelyAfter(e)}).to.throw("expected spyB to not have been called immediately after function spyA() {}")})}),describe("about call context",function(){it("should be correct for the basic case",function(){var e=sinon.spy(),t={},o={x:"y"};e.call(o);var n="expected spy to have been called with {  } as this, but it was called with "+e.printf("%t")+" instead";expect(function(){e.should.have.been.calledOn(t)}).to.throw(n),expect(function(){e.getCall(0).should.have.been.calledOn(t)}).to.throw(n)}),it("should be correct for the negated case",function(){var e=sinon.spy(),t={};e.call(t);var o="expected spy to not have been called with {  } as this";expect(function(){e.should.not.have.been.calledOn(t)}).to.throw(o),expect(function(){e.getCall(0).should.not.have.been.calledOn(t)}).to.throw(o)}),it("should be correct for the always case",function(){var e=sinon.spy(),t={},o={x:"y"};e.call(o);var n="expected spy to always have been called with {  } as this, but it was called with "+e.printf("%t")+" instead";expect(function(){e.should.always.have.been.calledOn(t)}).to.throw(n)})}),describe("about calling with new",function(){it("should be correct for the basic case",function(){var e=sinon.spy();e();var t="expected spy to have been called with new";expect(function(){e.should.have.been.calledWithNew}).to.throw(t),expect(function(){e.getCall(0).should.have.been.calledWithNew}).to.throw(t)}),it("should be correct for the negated case",function(){var e=sinon.spy();new e;var t="expected spy to not have been called with new";expect(function(){e.should.not.have.been.calledWithNew}).to.throw(t),expect(function(){e.getCall(0).should.not.have.been.calledWithNew}).to.throw(t)}),it("should be correct for the always case",function(){var e=sinon.spy();new e,e();expect(function(){e.should.always.have.been.calledWithNew}).to.throw("expected spy to always have been called with new")})}),describe("about call arguments",function(){it("should be correct for the basic cases",function(){var e=sinon.spy();e(1,2,3),expect(function(){e.should.have.been.calledWith("a","b","c")}).to.throw("expected spy to have been called with arguments a, b, c"),expect(function(){e.should.have.been.calledWithExactly("a","b","c")}).to.throw("expected spy to have been called with exact arguments a, b, c"),expect(function(){e.should.have.been.calledWithMatch(sinon.match("foo"))}).to.throw('expected spy to have been called with arguments matching match("foo")'),expect(function(){e.getCall(0).should.have.been.calledWith("a","b","c")}).to.throw("expected spy to have been called with arguments a, b, c"),expect(function(){e.getCall(0).should.have.been.calledWithExactly("a","b","c")}).to.throw("expected spy to have been called with exact arguments a, b, c"),expect(function(){e.getCall(0).should.have.been.calledWithMatch(sinon.match("foo"))}).to.throw('expected spy to have been called with arguments matching match("foo")')}),it("should be correct for the negated cases",function(){var e=sinon.spy();e(1,2,3),expect(function(){e.should.not.have.been.calledWith(1,2,3)}).to.throw("expected spy to not have been called with arguments 1, 2, 3"),expect(function(){e.should.not.have.been.calledWithExactly(1,2,3)}).to.throw("expected spy to not have been called with exact arguments 1, 2, 3"),expect(function(){e.should.not.have.been.calledWithMatch(sinon.match(1))}).to.throw("expected spy to not have been called with arguments matching match(1)"),expect(function(){e.getCall(0).should.not.have.been.calledWith(1,2,3)}).to.throw("expected spy to not have been called with arguments 1, 2, 3"),expect(function(){e.getCall(0).should.not.have.been.calledWithExactly(1,2,3)}).to.throw("expected spy to not have been called with exact arguments 1, 2, 3"),expect(function(){e.getCall(0).should.not.have.been.calledWithMatch(sinon.match(1))}).to.throw("expected spy to not have been called with arguments matching match(1)")}),it("should be correct for the always cases",function(){var e=sinon.spy();e(1,2,3),e("a","b","c");var t=/expected spy to always have been called with arguments 1, 2, 3/;expect(function(){e.should.always.have.been.calledWith(1,2,3)}).to.throw(t);var o=/expected spy to always have been called with exact arguments 1, 2, 3/;expect(function(){e.should.always.have.been.calledWithExactly(1,2,3)}).to.throw(o);var n=/expected spy to always have been called with arguments matching match\(1\)/;expect(function(){e.should.always.have.been.calledWithMatch(sinon.match(1))}).to.throw(n)})}),describe("about returning",function(){it("should be correct for the basic case",function(){var e=sinon.spy.create(function(){return 1});e(),expect(function(){e.should.have.returned(2)}).to.throw("expected spy to have returned 2"),expect(function(){e.getCall(0).should.have.returned(2)}).to.throw("expected spy to have returned 2")}),it("should be correct for the negated case",function(){var e=sinon.spy.create(function(){return 1});e(),expect(function(){e.should.not.have.returned(1)}).to.throw("expected spy to not have returned 1"),expect(function(){e.getCall(0).should.not.have.returned(1)}).to.throw("expected spy to not have returned 1")}),it("should be correct for the always case",function(){var e=sinon.spy.create(function(){return 1});e(),expect(function(){e.should.always.have.returned(2)}).to.throw("expected spy to always have returned 2")})}),describe("about throwing",function(){it("should be correct for the basic cases",function(){var e=sinon.spy(),t=sinon.spy.create(function(){throw new Error});e(),swallow(t),expect(function(){e.should.have.thrown()}).to.throw("expected spy to have thrown"),expect(function(){e.getCall(0).should.have.thrown()}).to.throw("expected spy to have thrown"),expect(function(){t.should.have.thrown("TypeError")}).to.throw("expected spy to have thrown TypeError"),expect(function(){t.getCall(0).should.have.thrown("TypeError")}).to.throw("expected spy to have thrown TypeError"),expect(function(){t.should.have.thrown({message:"x"})}).to.throw('expected spy to have thrown { message: "x" }'),expect(function(){t.getCall(0).should.have.thrown({message:"x"})}).to.throw('expected spy to have thrown { message: "x" }')}),it("should be correct for the negated cases",function(){var e=new Error("boo!"),t=sinon.spy.create(function(){throw e});swallow(t),expect(function(){t.should.not.have.thrown()}).to.throw("expected spy to not have thrown"),expect(function(){t.getCall(0).should.not.have.thrown()}).to.throw("expected spy to not have thrown"),expect(function(){t.should.not.have.thrown("Error")}).to.throw("expected spy to not have thrown Error"),expect(function(){t.getCall(0).should.not.have.thrown("Error")}).to.throw("expected spy to not have thrown Error"),expect(function(){t.should.not.have.thrown(e)}).to.throw("expected spy to not have thrown Error: boo!"),expect(function(){t.getCall(0).should.not.have.thrown(e)}).to.throw("expected spy to not have thrown Error: boo!")}),it("should be correct for the always cases",function(){var e=sinon.spy(),t=sinon.spy.create(function(){throw new Error});e(),swallow(t),expect(function(){e.should.have.always.thrown()}).to.throw("expected spy to always have thrown"),expect(function(){t.should.have.always.thrown("TypeError")}).to.throw("expected spy to always have thrown TypeError"),expect(function(){t.should.have.always.thrown({message:"x"})}).to.throw('expected spy to always have thrown { message: "x" }')})}),describe("when used on a non-spy/non-call",function(){function e(){}it("should be informative for properties",function(){expect(function(){e.should.have.been.called}).to.throw(TypeError,/not a spy/)}),it("should be informative for methods",function(){expect(function(){e.should.have.been.calledWith("foo")}).to.throw(TypeError,/not a spy/)})}),it("should not trigger getters for passing assertions",function(){var e={},t=!1;Object.defineProperty(e,"getter",{get:function(){t=!0},enumerable:!0});var o=sinon.spy();o(e),o.should.have.been.calledWith(e),expect(t).to.be.false})});